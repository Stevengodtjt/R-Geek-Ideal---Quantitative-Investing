#画图
g<-ggplot(data=df2,aes(x=dates,y=value,colour=variable))
g<-g+geom_line()
g<-g+scale_x_date(date_breaks = "1 week",date_labels='%m-%d')
g<-g+labs(x='date',y='Price')
g
# 图中，X轴为时间，Y轴是价格，红色线为X的产品的价格，蓝色线为Y产品的价格。
# 我们可以直观的看出，X、Y两个产品无任何关系
# 根据配对交易的假设条件，如果两个金融产品的价差是收敛的，接下来验证价差的收敛性。
# 我们用X的产品价格减去Y产品的价格，当差值为正的时候，我们认为X的价格过高，则做空X，同时Y的价格过低，则做多Y；
# 当差值为负的时候，我们认为X的价格过低，则做多X，同时Y的价格过高，则做空Y；
# 当差值为0时，价格被市场所修复，则全部平仓。
# 为了让差异更明显，我们定义的计算公式如下：
# 价差Z=X价格-Y价格
# Z>10时，做空X，做多Y；Z<0时，平仓
# Z<-10时，做多X，做空Y；Z>0时，平仓
#计算差价，然后计算交易统计
df$diff<-df$x-df$y
#找到差价大于10的点
idx<-which(df$diff>10)
idx<-idx[-which(diff(idx)==1)-1]
#打印差价的索引值
idx
# 接下来，我们进行模拟交易，取第一个索引值的点，在2010-01-04时做空X，做多Y。
# 当差价小于0，即在2010-01-06时，进行平仓
head(df,20)
#当差价大于10时，做空X，当差价小于0时，平仓
#第4行做空，第6行平仓
xprofit<- df$x[4]-df$x[6];xprofit
#当差价大于10时，做多Y，当差价小于0时，平仓
#第4行做空，第6行平仓
yprofit<- df$y[6]-df$y[4];yprofit
# 从交易结果来看，我们第一笔配对交易就是赚钱的。
# 原因：根据配对交易的假设条件，如果两个金融产品的价差是收敛的，通过协整性检验的方法，
# 我们可验证数据的收敛性。那么如果数据是收敛的，它还会具备均值回归的特性。
#画出X、Y的价差图
plot(df$diff,type='l')
# 可以明显的看出，价差一直围绕着0上下波动，这是明显收敛的，同时符合均值回归的特性
# 这就是市场的规则，通过配对交易的方法，我们找到市场的无效性，从而赚取套利的收益。
#6.3.3 用R语言实现配对交易
#1.数据准备
# 本节用到的数据，是铜的1分钟线的数据，从2016年日2月1日到2016年日2月29日日盘的交易数据，
# 以CSV格式保存到本地文件cu1605.csv和cu1606.csv。商品期货的日盘交易时间分为3段：9：00-10：15，
# 10：30-11：30，13：30-15：00。当前测试不考虑夜盘的数据。
setwd("D:/significant data备份/R/b站分享/R语言量化投资/part 3 金融策略实战 chapter 6 量化投资策略案例")
csv1<-read.csv(file="cu1605.csv")
csv2<-read.csv(file="cu1606.csv")
# 一共5列：
# ·第1列：交易时间，date
# ·第2列：开盘价，Open，35870。
# ·第3列：最高价，High，35900。
# ·第4列：最低价，Low，35860。
# ·第5列：收盘价，Close，35880。
# 通过R语言加载铜的1分钟线数据，因为我们进行日内交易，所以在加载时就进行了转换，
# 按日期进行分组，生成R语言的list对象，同时把每日的data.frame类型对象转成XTS时间序列类型对象，方便后续的数据处理
install.packages("xts")
install.packages("TTR")
library(xts)
library(TTR)
#读取csv数据文件
read<-function(file){
df<-read.table(file=file,header=FALSE,sep = ",", na.strings = "NULL") #读文件
names(df)<-c("date","Open","High","Low","Close")                      #设置列名
dl<-split(df,format(as.POSIXct(df$date),'%Y-%m-%d'))                  #按日期分组
lapply(dl,function(item){
xts(item[-1],order.by = as.POSIXct(item$date))                      #换成xts类型数据
})
}
#加载数据
cu1605<-read(file='cu1605.csv')
cu1606<-read(file='cu1606.csv')
#查看数据类型
class(cu1605)
#查看数据的日期索引值
names(cu1605)
#查看每日的数据量
nrow(cu1605[[1]])
#查看cu1605合约的数据
head(cu1605[['2016-02-01']])
#2.配对交易模型
# 以2016年2月1日为例进行交易，以1分钟线的close价格来计算cu1605和cu1606两个合约的价差。
# 下面我们对数据进行操作，合并2个合约在2016年2月1日的数据，并对空值进行处理，最后计算出两个合约的价差
#合并数据
xdf<-merge(cu1605[['2016-02-01']]$Close,cu1606[['2016-02-01']]$Close)
names(xdf)<-c('x1','x2')
#用前值替换空值
xdf<-na.locf(xdf)
#计算价差
xdf$diff<-xdf$x1-xdf$x2
#前20行
head(xdf,20)
# 数据解释：
# ·x1列：第一腿，对应cu1605合约。
# ·x2列：第二腿，对应cu1606合约。
# ·diff列：cu1605-cu1606。
#计算价差范围
range(xdf$diff)
#计算价差均值
mean(xdf$diff)
#画出价差分布柱状图
hist(xdf$diff,10)
# 从价差的结果看，每1分钟cu1605合约都小于cu1606合约，从-110到-20价差不等，并且以-63为均值上下反复震荡
# 假设以-63为均值回归点，当差值为大于-45的时候，认为X的价格过高做空X，同时Y的价格过低做多Y；
# 当差值小于-75的时候，认为X的价格过低做多X，同时Y的价格过高做空Y；
# 当差值为-63时，价格被市场所修复，则全部平仓。
# 以cu1605和cu1606的两个合约按照1∶1持仓进行配比，1手多单对1手空单。
#由于作者自己开发的配对交易软件包缺失，后续暂时缺失
#感兴趣的可直接参考作者后续分析：https://blog.csdn.net/fens/article/details/84634623?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166193551316782412585720%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166193551316782412585720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84634623-null-null.142^v44^pc_rank_34_default_2&utm_term=R%E8%AF%AD%E8%A8%80%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%98%93&spm=1018.2226.3001.4187
#1.数据准备
# 本节用到的数据，是铜的1分钟线的数据，从2016年日2月1日到2016年日2月29日日盘的交易数据，
# 以CSV格式保存到本地文件cu1605.csv和cu1606.csv。商品期货的日盘交易时间分为3段：9：00-10：15，
# 10：30-11：30，13：30-15：00。当前测试不考虑夜盘的数据。
setwd("D:/significant_data/R/b站分享/R语言量化投资/part 3 金融策略实战 chapter 6 量化投资策略案例")
csv1<-read.csv(file="cu1605.csv")
csv2<-read.csv(file="cu1606.csv")
# 一共5列：
# ·第1列：交易时间，date
# ·第2列：开盘价，Open，35870。
# ·第3列：最高价，High，35900。
# ·第4列：最低价，Low，35860。
# ·第5列：收盘价，Close，35880。
# 通过R语言加载铜的1分钟线数据，因为我们进行日内交易，所以在加载时
library(xts)
library(TTR)
#读取csv数据文件
read<-function(file){
df<-read.table(file=file,header=FALSE,sep = ",", na.strings = "NULL") #读文件
names(df)<-c("date","Open","High","Low","Close")                      #设置列名
dl<-split(df,format(as.POSIXct(df$date),'%Y-%m-%d'))                  #按日期分组
lapply(dl,function(item){
xts(item[-1],order.by = as.POSIXct(item$date))                      #换成xts类型数据
})
}
#加载数据
cu1605<-read(file='cu1605.csv')
cu1606<-read(file='cu1606.csv')
#查看数据类型
class(cu1605)
#查看数据的日期索引值
names(cu1605)
#查看每日的数据量
nrow(cu1605[[1]])
#查看cu1605合约的数据
head(cu1605[['2016-02-01']])
#2.配对交易模型
# 以2016年2月1日为例进行交易，以1分钟线的close价格来计算cu1605和cu1606两个合约的价差。
# 下面我们对数据进行操作，合并2个合约在2016年2月1日的数据，并对空值进行处理，最后计算出两个合约的价差
#合并数据
xdf<-merge(cu1605[['2016-02-01']]$Close,cu1606[['2016-02-01']]$Close)
names(xdf)<-c('x1','x2')
#用前值替换空值
xdf<-na.locf(xdf)
#计算价差
xdf$diff<-xdf$x1-xdf$x2
#前20行
head(xdf,20)
# 数据解释：
# ·x1列：第一腿，对应cu1605合约。
# ·x2列：第二腿，对应cu1606合约。
# ·diff列：cu1605-cu1606。
#计算价差范围
range(xdf$diff)
#计算价差均值
mean(xdf$diff)
#画出价差分布柱状图
hist(xdf$diff,10)
# 从价差的结果看，每1分钟cu1605合约都小于cu1606合约，从-110到-20价差不等，并且以-63为均值上下反复震荡
# 假设以-63为均值回归点，当差值为大于-45的时候，认为X的价格过高做空X，同时Y的价格过低做多Y；
# 当差值小于-75的时候，认为X的价格过低做多X，同时Y的价格过高做空Y；
# 当差值为-63时，价格被市场所修复，则全部平仓。
# 以cu1605和cu1606的两个合约按照1∶1持仓进行配比，1手多单对1手空单。
#由于作者自己开发的配对交易软件包缺失，后续暂时缺失
#感兴趣的可直接参考作者后续分析：https://blog.csdn.net/fens/article/details/84634623?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166193551316782412585720%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166193551316782412585720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84634623-null-null.142^v44^pc_rank_34_default_2&utm_term=R%E8%AF%AD%E8%A8%80%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%98%93&spm=1018.2226.3001.4187
#6.3.2 配对交易模型
# 根据概念，我们生成两个虚拟的金融产品X、Y，包括时间和价格字段。
# 让X和Y的两个产品都价格符合正态分布，生成100个日期的数据。
# 由于是测试程序，日期字段包括了自然日，暂时理解为连续的日期。
set.seed(1)                         #设置随机种子
dates<-as.Date('2010-01-01')+1:100  #100个日期
x<-round(rnorm(100,50,40),2)        #随机生成X产品，100个正态分析的收盘价
y<-round(rnorm(100,50,40),2)        #随机生成Y产品，100个正态分析的收盘价
df<-data.frame(dates,x,y)
head(df,20)
#把数据进行可视化
install.packages("ggplot2")
install.packages("scales")
install.packages("reshape2")
library(ggplot2)
library(scales)
library(reshape2)
#数据转型
df2<-melt(df,c('dates'))
#画图
g<-ggplot(data=df2,aes(x=dates,y=value,colour=variable))
g<-g+geom_line()
g<-g+scale_x_date(date_breaks = "1 week",date_labels='%m-%d')
g<-g+labs(x='date',y='Price')
g
# 图中，X轴为时间，Y轴是价格，红色线为X的产品的价格，蓝色线为Y产品的价格。
# 我们可以直观的看出，X、Y两个产品无任何关系
# 根据配对交易的假设条件，如果两个金融产品的价差是收敛的，接下来验证价差的收敛性。
# 我们用X的产品价格减去Y产品的价格，当差值为正的时候，我们认为X的价格过高，则做空X，同时Y的价格过低，则做多Y；
# 当差值为负的时候，我们认为X的价格过低，则做多X，同时Y的价格过高，则做空Y；
# 当差值为0时，价格被市场所修复，则全部平仓。
# 为了让差异更明显，我们定义的计算公式如下：
# 价差Z=X价格-Y价格
# Z>10时，做空X，做多Y；Z<0时，平仓
# Z<-10时，做多X，做空Y；Z>0时，平仓
#计算差价，然后计算交易统计
df$diff<-df$x-df$y
#找到差价大于10的点
idx<-which(df$diff>10)
idx<-idx[-which(diff(idx)==1)-1]
#打印差价的索引值
idx
# 接下来，我们进行模拟交易，取第一个索引值的点，在2010-01-04时做空X，做多Y。
# 当差价小于0，即在2010-01-06时，进行平仓
head(df,20)
#当差价大于10时，做空X，当差价小于0时，平仓
#第4行做空，第6行平仓
xprofit<- df$x[4]-df$x[6];xprofit
#当差价大于10时，做多Y，当差价小于0时，平仓
#第4行做空，第6行平仓
yprofit<- df$y[6]-df$y[4];yprofit
# 从交易结果来看，我们第一笔配对交易就是赚钱的。
# 原因：根据配对交易的假设条件，如果两个金融产品的价差是收敛的，通过协整性检验的方法，
# 我们可验证数据的收敛性。那么如果数据是收敛的，它还会具备均值回归的特性。
#画出X、Y的价差图
plot(df$diff,type='l')
# 可以明显的看出，价差一直围绕着0上下波动，这是明显收敛的，同时符合均值回归的特性
# 这就是市场的规则，通过配对交易的方法，我们找到市场的无效性，从而赚取套利的收益。
#6.3.3 用R语言实现配对交易
#1.数据准备
# 本节用到的数据，是铜的1分钟线的数据，从2016年日2月1日到2016年日2月29日日盘的交易数据，
# 以CSV格式保存到本地文件cu1605.csv和cu1606.csv。商品期货的日盘交易时间分为3段：9：00-10：15，
# 10：30-11：30，13：30-15：00。当前测试不考虑夜盘的数据。
setwd("D:/significant_data/R/b站分享/R语言量化投资/part 3 金融策略实战 chapter 6 量化投资策略案例")
csv1<-read.csv(file="cu1605.csv")
csv2<-read.csv(file="cu1606.csv")
# 一共5列：
# ·第1列：交易时间，date
# ·第2列：开盘价，Open，35870。
# ·第3列：最高价，High，35900。
# ·第4列：最低价，Low，35860。
# ·第5列：收盘价，Close，35880。
# 通过R语言加载铜的1分钟线数据，因为我们进行日内交易，所以在加载时就进行了转换，
# 按日期进行分组，生成R语言的list对象，同时把每日的data.frame类型对象转成XTS时间序列类型对象，方便后续的数据处理
install.packages("xts")
install.packages("TTR")
library(xts)
library(TTR)
#读取csv数据文件
read<-function(file){
df<-read.table(file=file,header=FALSE,sep = ",", na.strings = "NULL") #读文件
names(df)<-c("date","Open","High","Low","Close")                      #设置列名
dl<-split(df,format(as.POSIXct(df$date),'%Y-%m-%d'))                  #按日期分组
lapply(dl,function(item){
xts(item[-1],order.by = as.POSIXct(item$date))                      #换成xts类型数据
})
}
#加载数据
cu1605<-read(file='cu1605.csv')
cu1606<-read(file='cu1606.csv')
#查看数据类型
class(cu1605)
#查看数据的日期索引值
names(cu1605)
#查看每日的数据量
nrow(cu1605[[1]])
#查看cu1605合约的数据
head(cu1605[['2016-02-01']])
#2.配对交易模型
# 以2016年2月1日为例进行交易，以1分钟线的close价格来计算cu1605和cu1606两个合约的价差。
# 下面我们对数据进行操作，合并2个合约在2016年2月1日的数据，并对空值进行处理，最后计算出两个合约的价差
#合并数据
xdf<-merge(cu1605[['2016-02-01']]$Close,cu1606[['2016-02-01']]$Close)
names(xdf)<-c('x1','x2')
#用前值替换空值
xdf<-na.locf(xdf)
#计算价差
xdf$diff<-xdf$x1-xdf$x2
#前20行
head(xdf,20)
# 数据解释：
# ·x1列：第一腿，对应cu1605合约。
# ·x2列：第二腿，对应cu1606合约。
# ·diff列：cu1605-cu1606。
#计算价差范围
range(xdf$diff)
#计算价差均值
mean(xdf$diff)
#画出价差分布柱状图
hist(xdf$diff,10)
# 从价差的结果看，每1分钟cu1605合约都小于cu1606合约，从-110到-20价差不等，并且以-63为均值上下反复震荡
# 假设以-63为均值回归点，当差值为大于-45的时候，认为X的价格过高做空X，同时Y的价格过低做多Y；
# 当差值小于-75的时候，认为X的价格过低做多X，同时Y的价格过高做空Y；
# 当差值为-63时，价格被市场所修复，则全部平仓。
# 以cu1605和cu1606的两个合约按照1∶1持仓进行配比，1手多单对1手空单。
#由于作者自己开发的配对交易软件包缺失，后续暂时缺失
#感兴趣的可直接参考作者后续分析：https://blog.csdn.net/fens/article/details/84634623?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166193551316782412585720%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166193551316782412585720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84634623-null-null.142^v44^pc_rank_34_default_2&utm_term=R%E8%AF%AD%E8%A8%80%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%98%93&spm=1018.2226.3001.4187
#画出价差分布柱状图
hist(xdf$diff,10)
#计算价差范围
range(xdf$diff)
#计算价差均值
mean(xdf$diff)
library(plyr)
library(xts)
library(TTR)
library(ggplot2)
library(scales)
setwd("D:/significant_data/R/b站分享/R语言量化投资/part 3 金融策略实战 chapter 6 量化投资策略案例")
csv<-read.csv(file="stock.csv")
#读取csv数据文件
read<-function(file){
df<-read.table(file=file,header=FALSE,sep = ",", na.strings = "NULL") #读文件
names(df)<-c("code","date","Open","High","Low","Close","Volume")      #设置列名
dl<-split(df[-1],df$code)                                             #按code分组
lapply(dl,function(row){                                              #换成xts类型的数据
xts(row[-1],order.by = as.Date(row$date))
})
}
#加载数据
data<-read("stock.csv")
#查看数据类型
class(data)
#查看数据的索引值
head(names(data))
#查看包括的股票数量
length(data)
#获得时间范围
dateArea<-function(sDate,eDate,before=0){
return(paste(sDate-before,eDate,sep="/"))
}
#查看股票000001.SZ
head(data[['000001.SZ']])
#2.追涨杀跌模型
# 为了能拉近我们对市场的了解，取从2015年1月1日开始的数据来创建追涨杀跌的模型。以茅台
# （600519）为例，画出茅台自2015年以来的每日收盘价，以及20日最高价和10日最低价。
#日k线数据
title<-'600519.SH'
stock<-data[[title]]                           #获得股票数据
sDate<-as.Date("2015-01-01")                   #开始日期
eDate<-as.Date("2015-07-16")                   #结束日期
cdata<-stock[dateArea(sDate,eDate)]$Close  #获得收盘价
vdata<-stock[dateArea(sDate,eDate)]$Volume #获得交易量
#收盘价
names(cdata)<-"Value"  #重置列名
tail(cdata)
#交易量
tail(vdata)
#定义画图函数drawLine（），支持画出多条曲线，包括收盘价、最高价、最低价
drawLine<-function(cdata,titie="Stock",sDate=min(index(cdata)),eDate=max(index(cdata)),breaks="1 year"){
if(sDate<min(index(cdata))) sDate=min(index(cdata))
if(eDate>max(index(cdata))) eDate=max(index(cdata))
cdata<-na.omit(cdata)
g<-ggplot(aes(x=Index, y=Value),data=fortify(cdata[,1],melt=TRUE))
g<-g+geom_line()
if(ncol(cdata)>1){ #多条线
g<-g+geom_line(aes(colour=Series),data=fortify(cdata[,-1],melt=TRUE))
}
g<-g+scale_x_date(labels=date_format("%Y-%m"),breaks=date_breaks(breaks),limits = c(sDate,eDate))
g<-g+ylim(min(cdata$Value), max(cdata$Value))
g<-g+xlab("") + ylab("Price")+ggtitle(title)
g
}
drawLine(cdata,title,sDate,eDate,'1 month') #画出收盘价
#计算最近20日的最高价和10日的最低价
minmax<-function(data,max=20,min=10){
d1<-na.locf(data,fromLast=TRUE)
d2<-merge(d1,min=runMin(d1,min),max=runMax(d1,max))
return(d2[,-1])
}
#画出股价，最高价和最低价
ldata<-cbind(cdata,minmax(cdata))
drawLine(ldata,title,sDate,eDate,'1 month')
# 图中有3条线，黑色线为茅台的每日收盘价，上方蓝色线为最近20日最高价，下方红色线为最近10日最低价
# 根据模型的计算公式，我们计算买入信号，当股价向上突破最近20日最高价格时买入
#买入信号函数
buyPoint<-function(ldata){
idx<-which(ldata$Value == ldata$max)
return(ldata[idx,])
}
#计算买入的点
buydata<-buyPoint(ldata)
buydata
#画出买入的信号图，可以直观地看到效果
drawPoint<-function(ldata,pdata,titie,sDate,eDate,breaks="1 year"){
ldata<-na.omit(ldata)
g<-ggplot(aes(x=Index, y=Value),data=fortify(ldata[,1],melt=TRUE))
g<-g+geom_line()
g<-g+geom_line(aes(colour=Series),data=fortify(ldata[,-1],melt=TRUE))
if(is.data.frame(pdata)){
g<-g+geom_point(aes(x=Index,y=Value,colour=op),data=pdata,size=4)
}else{
g<-g+geom_point(aes(x=Index,y=Value,colour=Series),data=na.omit(fortify(pdata,melt=TRUE)),size=4)
}
g<-g+scale_x_date(labels=date_format("%Y-%m"),breaks=date_breaks(breaks),limits = c(sDate,eDate))
g<-g+xlab("") + ylab("Price")+ggtitle(title)
g
}
drawPoint(ldata,buydata$Value,title,sDate,eDate,'1 month')
# 如图所示，实心点为股价大于等于最近20日最高价的点，作为买入信号。
# 所有买入信号点都出现在单边上行的牛势中，对2015年上半年以来的行情来说，追涨的信号会被大量触发
# 接下来，我们继续计算卖出信号点，当股价小于等于最近10日最低价时作为卖出信号点。
#计算卖出信号点
stopPoint<-function(ldata,buydata){
idx<-which(ldata$Value == ldata$min)
idx<-idx[which(c(0,diff(idx))!=1)]       #第一点用0表示
selldata<-ldata[idx,]                    #所有低于最小值的点
idx2<-sapply(index(buydata),function(e){ #买后的卖点
head(which(index(selldata)>e),1)
})
return(selldata[unique(idx2),])
}
#卖出信号
selldata<-stopPoint(ldata,buydata)
selldata
#一共有2笔卖出信号,为了让数据更加直观，我们合并买入信号和卖出信号，进行画图可视化
bsdata<-merge(buydata$Value,selldata$Value)
names(bsdata)<-c("buy","sell")
drawPoint(ldata,bsdata,title,sDate,eDate,'1 month')
# 图中，紫色圆点为卖出信号点，红色圆点为买入信号点。我们可以很明显地看出，
# 如果根据交易信号在红色点买入，紫色点卖出，是应该赚钱的。那么具体赚了多少呢，需要计算出来
#合并交易信号
signal<-function(buy, sell){
selldf<-data.frame(sell,op=as.character(rep("S",nrow(sell))))
buydf<-data.frame(buy,op=as.character(rep("B",nrow(buy))))
sdata<-rbind(buydf,selldf)
#交易信号数据
sdata[order(as.Date(row.names(sdata))),]
}
sdata<-signal(buydata,selldata)
sdata
# 接下来，我们利用交易信号数据，进行模拟交易。设定交易参数和规则：
# ·以10万元人⺠币为本金。
# ·买入信号出现时，以收盘价买入，每次买入价值1万元的股票。如果连续出现买入信号，则一直买入。若现金不足1万元，则跳过买入信号。
# ·卖出信号出现时，以收盘价卖出，一次性平仓信号对应的股票。
# ·手续费为0元。
# 下面进行模拟交易：
trade<-function(sdata,capital=100000,fixMoney=10000){ #交易信号，总资金，每次定投资金
amount<-0
cash<-capital
ticks<-data.frame()
for(i in 1:nrow(sdata)){
row<-sdata[i,]
if(row$op=='B'){
if(cash<fixMoney){
print(paste(row.names(row),"No enough cash"))
next
}
amount0<-floor(fixMoney/row$Value)             #本次交易量
amount<-amount+amount0
cash<-cash-amount0*row$Value
}
if(row$op=='S'){
cash<-cash+amount*row$Value
amount<-0
}
row$cash<-round(cash,2)
row$amount<-amount
row$asset<-round(cash+amount*row$Value,2)
ticks<-rbind(ticks,row)
}
ticks$diff<-c(0,round(diff(ticks$asset),2))
rise<-ticks[intersect(which(ticks$diff>0),which(ticks$op=='S')),] #赚钱的交易
fall<-ticks[intersect(which(ticks$diff<0),which(ticks$op=='S')),] #赔钱的交易
return(list(ticks=ticks,rise=rise,fall=fall))
}
result<-trade(sdata,100000,10000)  #交易结果(有6次现金不足)
result$ticks #交易明细
nrow(result$ticks)
# 一共发生了15笔交易，其中13笔买入，2笔卖出。最后，资金剩余121837.2元，赚了21837.2元，收益率为22%
#模型策略2：当股价低于前一个买入点的价格时进行卖出，小于10日最低价为止损点
#计算卖出的信号点
sellPoint<-function(ldata,buydata){
arr<-c()
for(i in 1:nrow(buydata)){
if(i>1){                               #跳转第一个点
date<-index(buydata[i,])
#价格小于上一次的买入价格就跳出
last<-as.vector(buydata[i-1,]$Value) #上一次买入的价格
lst<-ldata[paste(date,"/",sep="")]$Value
idx<-head(which(lst < last),1)
if(length(idx)>0){
arr<-rbind(arr,index(lst[idx]))
}
}
}
selldata<-ldata[as.Date(unique(arr)),]
#过滤多余的卖出点
bsdata<-merge(buydata$Value,selldata$Value)
names(bsdata)<-c("buy","Value")
idx1<-which(!is.na(bsdata$Value))
idx2<-idx1[which(c(0,diff(idx1))==1)]
bsdata$Value[idx2]<-NA
return(bsdata$Value[which(!is.na(bsdata$Value))])
}
#卖出信号
selldata<-sellPoint(ldata,buydata)
selldata
nrow(selldata) #卖出的信号点有7个，比上次多5个
#合并交易信号
sdata<-signal(buydata$Value,selldata$Value)
sdata
result<-trade(sdata,100000,10000)  #交易结果
result$ticks #交易明细（收益不如策略1）
#可视化
stopdata<-stopPoint(ldata,buydata)                         #止损信号
bsdata<-merge(buydata$Value,selldata$Value,stopdata$Value) #合并买卖信号、止损信号
names(bsdata)<-c("buy","sell","stop")
drawPoint(ldata,bsdata,title,sDate,eDate,'1 month')        #画图
